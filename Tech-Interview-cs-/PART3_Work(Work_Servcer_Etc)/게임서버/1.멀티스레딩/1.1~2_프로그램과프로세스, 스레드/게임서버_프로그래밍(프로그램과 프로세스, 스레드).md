## 1장 멀티스레딩

- 게임 서버를 개발하면 필연적으로 멀티스레드 프로그래밍을 하게 된다.
- 싱글스레드로만 작동하는 비동기 함수 콜백(asynchronous callback)이나 코루틴(coroutine)을 쓰더라도 멀티스레딩을 이해하면 유용하다.
- 멀티스레드가 무엇이고, 왜 써야하는 지 알아본다.

---

### 1.1 프로그램과 프로세스

- 프로그램이란 컴퓨터에서 실행되는 명령어 모음이 들어있는 데이터 덩이리를 의미한다. 코드(code)와 데이터(data)로 구성되어 있다.
- 프로그램 자체는 아무런 의미가 없다. 그것을 더블클릭하여 실행시키기 전까지는
- 프로그램을 실행하면 프로그람 안에 들어있는 명령어가 한줄 씩 실행되며 프로그램은 뭔가 활동을 하는 상태가 되고 이를 **프로세스(process)**라고 한다.

- 프로그램에 있는 코드와 데이터는 프로세스 메모리로 불러들인다. 즉 로딩된다.
- 프로세스 메모라에 프로그램 코드와 데이터는 물론 힙(heap)과 스택(stack)도 공존한다.
- 스택에는 현재 실행 중인 함수들의 호출 기록과 사용 중인 로컬 변수들이 들어 있다.

![프로세스 메모리 구조](image.png)

- 윈도 운영체제에서 실행된 프로그램을 작업관리자로 확인할 수 있다.
- 기기 안에서 실행 중인 프로세스는 여러개이다.
- 같은 프로그램을 여러 개 동시에 실행할 수 도 있다.

![멀티 프로세스 메모리 구조](image-2.png)

- 프로세스가 여러 개 실행되고 있는 것을 멀티프로세싱(multi-processing)이라고 한다.

### 1.2 스레드

- 프로세스에 독립된 메모리 공간이 있다. 기본적으로 서로 다른 프로세스는 상대방의 메모리 공간을 읽고 쓸 수 없다.

- 운영체제는 대부분 스레드(thread)라는 기능을 제공한다.
- 스레드 역시 프로세스 처럼 명령어를 한 줄 씩 실행하는 기본 단위이다. 스레드와 프로세스 차이점은 다음과 같다.
  - 스레드는 한 프로세스 안에 여러 개가 있다.
  - 한 프로세스 안에 있는 스레드는 프로세스 안에 있는 메모리 공간을 같이 사용할 수 있다.
- 스레드마다 스택을 가진다. 각 스레드에서 실행되는 함수의 로컬 변수들이 스레드마다 있다는 의미이다.

![프로세스와 스레드](image-3.png)

- 프로그램이 실행되는 기본 단위는 스레드이다.
- **프로그램을 실행하면 프로세스가 생성된다. 프로세스 안에는 유일한 스레드가 있고 그 안에서 프로그램이 실행된다.**

- 하나의 스레드만 실행되는 프로그램, 즉 지금까지 우리가 알던 '동시에 하나만 실행되는 프로그램'을 싱글스래드 프로그램이라 한다.
- 싱글스레드로만 작동화도록 프로그램을 설계하고 구현하는 것을 싱글스레드 모델(single threaded model)이라고 한다.

![싱글스레드](image-4.png)

- 기본으로 존재하는 스레드를 메인 스레드(main thread)라고 한다.
- 대부분 메인 스레드에서 프로그램을 실행했던 것이다.

- 프로세스 안에서 여러 스레드를 생성시킬 수 있다.
- 여러 스레드는 동시에 한꺼번에 실행된다. 여러 스레드가 동시에 여러 가지 일을 처리하게 하는 것을 **멀티스레드 혹은 멀티스레딩** 이라고 한다.

![멀티스레드](image-5.png)

- 위처럼 메인 스레드가 스레드 2와 스레드 3을 만들기 위해선 아래 코드처럼 하면 된다.

```c#
void main()
{
  t2 = CreateThread(Thread2Proc);
}

void Thread2Proc()
{
  t3 = CreateThread(Thread3Proc);
}

void Thread3Proc()
{
  ...
}
```

- 프로그램은 많은 함수로 구성되어 있다.
- C언어에서 void main() 함수가 실행되고 C#에서 메인 클래스의 Main()함수가 실행된다.
- 함수는 실행이 끝나면 자신을 호출했던 호출자(caller) 함수를 실행했던 지점으로 되돌아가야 한다.
- 어디까지 실행하다 말았는지를 기억을 해야하고 해당 정보가 저장되어 있는 곳을 호출 스택(call stack)이라고 한다.
- 디버거를 사용해서 호출 스택을 확인할 수 있다.

- 간단한 프로그램을 만단 후 func3()에 디버그 중단점을 찍고 디버깅을 실행할 수 있다.

![디버깅](image-6.png)

- 디버거가 일시 정지 시키고 상태에서 Debug에 있는 호출 스택(Call stack)을 확인한다.
- 호출 스택 안에는 각 함수 안에 선언된 지역 변수(혹은 로컬변수)도 같이 들어있다.
- 각 스레드는 실행 지점이 서로 다를수 밖에 없다. 스레드를 실행할 때 스레드가 최초로 실행할 함수를 지정하는데, 함수가 서로 다르기 때문이다.
- 같은 함수라도 넘긴 인자나 메모리 상태 등이 달라 다른 실행 지점을 가리킬 수 밖에 없다.
- 모두 동일해도 실행 시점은 약간 차이가 생기기도 한다.

- 각 스레드는 각자 호출 스택을 가진다.

![스레드, 호출 스택, 합의 관계](image-7.png)

- 스레드를 생성하려면 운영체제나 런타임 라이브러리에서 제공하는 스레드 생성용 함수를 호출한다.
- 인자로 최초로 실행할 함수, 함수가 받아들일 매개변수를 넣어야 한다.

- 다음 코드는 예제다.

![스레드 일생](image-8.png)

- 멀티스레드 프로그래밍 핵심은 **동시성(Concurrency)**와 **동기화(Synchronization)**이다.

- 1. 스레드의 생성 (Thread Createion)

  - **메인 스레드**가 `CreateThread()`를 호출, **스레드 1**을 생성한다.
  - 이때 실행할 함수(`ThreadProc`)와 데이터(`123`)을 인자로 넘겨줘 역할 분담을 시작한다.

- 2. 비결정적 실행

  - **상태**: 메인 스레드는 지점 2로, 스레드 1은 지점 5로 각각 이동하여 실행한다.
  - 주의점: 2와 5중 무엇이 먼저 실행될 지 모른다.
    - OS 스케줄링에 따라 무작위로 결정된다.
    - 두 스레드가 동시에 실행되는 '병렬성'의 특징이다.

- 3. 스레드 대기

  - 메인 스레드가 `Join()` 함수(3)를 만나면 **스레드1이 끝날때까지 대기** 상태에 들어간다.
  - 스레드 1이 아직 작업 중이면, 메인 스레드는 실행을 일시 정지하고 기다린다.

- 4. 종료 및 소멸

  - 스레드 1이 모든 로직(5)를 마치고 리턴하면 **스레드 1은 소멸**된다.
  - 스레드 1이 소멸되고 동시에 기다리던 메인 스레드는 대기를 끝내고 다음 코드를 실행한다.

- 상태변화와 실행 메커니즘

- 1. 스레드 생명주기

  - Runnable(실행 가능): 스레드가 생성되어 명령어를 실행 중인 상태다.
  - Blocked(대기): 다른 자원이나 스레드의 종료를ㄹ 기다리며 일시 정지된 상태다. 조건이 충족되면 다시 Runnable로 돌아간다.
  - Dead(소멸): 모든 작업을 마치고 리턴하여 스레드가 완전히 종료된 상태다.

- 2. 종료 및 주의사항
  - 스레드 1이 먼저 종료된 경우
    - 스레드1이 작업을 마치고 리턴하여 먼저 Dead 상태가된다.
    - 메인 스레드가 `Join()`을 호출, 기다릴 필요 없이 즉시 다음 단계로 넘어가 프로세스를 종료한다.
  - 메인 스레드가 먼저 종료되는 경우
    - 메인 스레드가 끝났음에도 다른 스레드가 살아있다면 프로세스는 종료되지 않고 메모리에 남게 된다.
    - 이런 현상을 **좀비 프로세스**라고 하고, 프로그램이 정상적으로 닫히지 않는 이상 현상 원인이 된다.
    - 모든 스레드가 종료되어야 프로세스 전체가 완전히 종료된다.

```WIN
DWORD threadID;
ThreadParam threadParam;
threadParam.value = 123;

CreateThread(
    ...,
    ThreadProc, &threadParam,
    ...,
    &threadID
);
```

- Liunx / Unix

```C++
pthread_t thread;
ThreadParam threadParam;
threadParam.value = 123;

thread_create(&thread, NULL, ThreadProc, &threadParam);
```

- Modern C++

```C++
// 플랫폼에 상관없이 동일한 문법 사용
std::thread t1(ThreadProc, 123);
```

> Tip
> 게임 개발을 할 때는 C++뿐만 아니라 C#, 자바, 자바스크립트, 파이썬, Lua 등 다양하게 사용합니다. 우리는 여기서 주로 C++를 사용하겠습니다. C++는 성능과 관련하여 부작용이 거의 없으며 대부분 플랫폼에서 사용할 수 있는 언어이기 때문입니다.
