## 1장 멀티스레딩

---

### 1.3 멀티스레드 프로그래밍은 언제 해야 하나?

- 똑같은 연산을 해도 멀티스레드로 할 경우 연산 속도가 훨씬 더 느려지기도 한다.
- 멀티스레드 프로그래밍은 조금만 실수해도 오류를 일으키고, 오류를 찾기 힘들때도 많다.

- 왜 해야 하지라는 답을 분명하게 해야한다.
  - 1. 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
  - 2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
  - 3. 기기에 있는 CPU를 모두 활용할 때

#### 1.3.1 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때

- 게임 프로그램의 로딩의 예.

- 게임을 켜고 스테이지 들어가기 전, 그래픽 리소스를 로딩하기 위해 많은 양의 데이터를 읽어야 한다.
- 지루함을 덜고자 로딩을 통해 그래프로 보여준다.
- 혹은 애니메이션 등을 화면에 뿌려주거나 요즘엔 간단한 미니게임을 넣는 경우도 있다.(남코의 저작권이 있었으나 15년에 풀렸다.)

- 멀티스레딩을 하지 않는다면 하나 로딩하고 렌더링하기를 반복해야 한다.

```c++
LoadScene()
{
  Render();
  LoadScene();
  Render();
  LoadModel();
  Render();
  LoadTexture();
  Render();
  LoadAnimation();
  Render();
  LoadSound();
}
```

- 큰 파일을 로딩하는 동안 프레임률이 끊길 것이다.
- 큰파일은 부분(chunk)단위로 로딩하며 렌더링을 할 예정이다.

- 아래처럼 멀티 스레드를 이용하면 문제를 해결할 수 있다.

```c++
bool isStillLoading; // 전역 변수

Thread1
{
  isStillLoading = true;
  while (isStillLoading)
  {
      FrameMove();
      Render();
  }
}

Thread2
{
  LoadScene();
  LoadModel();
  LoadTexture();
  LoadAnimation();
  LoadSound();

  isStillLoading = false;
}
```

- Thread1에서 게임루프를 돈다. 렌더링을 지속적으로 수행한다.
- Thread2에서 게임에 필요한 데이터를 디스크에서 로딩한다.
- 로딩이 끝나면 특정 변수를 변경하고 Thread1에서 변수가 변경될 때까지 로딩 화면을 반복해서 렌더링 한다.

---

#### 1.3.2 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때

- 플레이어 정보를 읽거나 쓰기위해 디스크를 액세스하는 경우다.
- 디스크를 액세스 하는 스레드는 처리 결과가 끝날 때까지 기다려야 하는데 이때 CPU가 놀기 때문에, 서버의 실행 성능을 개선할 수 있다.
- 현대(2026년)의 SSD는 초당 수백만 번의 작업을 처리할 만큼 강력해졌습니다. 하지만 실시간 게임 서버에서 요구하는 데이터 처리량과 복잡도는 그보다 훨씬 가파르게 증가했습니다.
- 여전히 디스크는 시스템에서 가장 느린 구간이며, 이를 효율적으로 다루기 위한 비동기/논블로킹 설계는 하드웨어 성능과 관계없이 필수적인 기술입니다.

- 1만분의 1초라는 매우 긴 시간을 효율적으로 활용하기 위해 멀티스레딩을 하든지 비동기 프로그래밍을 해야 한다.

---

#### 1.3.3 기기에 있는 CPU를 모두 홝용

- CPU의 실행 속도, 클록 수가 계속 증가했다. 그 이후부터 CPY의 클록 수 대신 CPU 코어 개수만 증가했다.
- CPU가 처리할 수 있는 기능들만 추가되고 있을 뿐이다. 제일 중요한 CPU 자체 속도는 증가하지 못했다.

- 스레드는 코어를 하나만 사용한다.
- 다음 코드는 소수 (2, 3, 5, 7처럼 1과 자기 자신을 제외한 나머지 숫자로 나뉘지 않는 정수)를 찾아내서 출력하는 프로그램이다.

```c#
#inClude <vector>
#inClude <iostream>
#inClude <chrono>

using namespace std;
const int MaxCount = 150000;

bool IsPrimeNumber(int number)
{
  if (number == 1) {
    return false;
  }
  if (number == 2 || number == 3) {
    return true;
  }
  for (int i = 2; i < number - 1; i++) {
    if ((number % i) == 0) {
      return false;
    }
  }
  return true;
}

void PrintNumbers(const vector<int>& primes)
{
  for (int v : primes) {
    count << v << endl;
  }
}

void main()
{
  vector<int> primes;

  auto t0 = chrono::system_clock::now();

  for (int i = 1; i <= MaxCount; i++)
  {
    if (IsPrimeNumber(i))
    {
      primes.push_back(i);
    }
  }
  auto t1 = chroo::system_clock::now();
  auto duration = chrono::duration_cast<chrono::milliseconds>(t1 - t0).count();
  count << "Took " << duration << "milliseconds. " << endl;

  PrintNumbers(primes);
}
```

- 이 프로그램을 실행하면 소수를 계산하는데 걸린 시간을 표시한다.

```bash
Took 3920 milliseconds.
```

- MaxCount를 훨씬 큰 수로 바꾼 후 실행해 본다. 프로그램이 실행을 완료하는 데 오랜 시간이 걸린다.
- 전체 CPU 성능의 1/8 밖에 사용하지 못할 것이다.

![소수 구하기 때문에 CPU 전체를 못쓰는 상황](image-10.png)

![CPU 하나로만 연산을 처리하는 상황](image-11.png)

- 4코어 CPU를 쓴다고 가정, 실제로는 CPU 1개만 사용되고 있다.

- 문제를 해결하려면 멀티스레드로 프로그램이 작동되게 만들어야 한다.
- 멀티스레드나 멀티프로세싱을 사용 여러 CPU를 쓰는 별도의 프로그래밍 노력을 해야하는 상황.

> 이해를 돕고자 일부러 CPU 1에서만 연산을 하는 것처럼 표현했습니다. 실제로는 CPU 1~4를 오가면서 실행됩니다.
> 5 출처: http://www.gotw.ca/publications/concurrency-ddj.htm

- 여러 CPU를 써서 소수를 구하는 프로그램을 만드면 일정한 크기만큼 분할해서 계산
- 정수 1부터 100만까지 중에서 소수를 찾는다.
  - CPU 1: 정수 1~25만 중에서 소수를 찾는다.
  - CPU 2: 정수 25~50만 중에서 소수를 찾는다.
  - CPU 3: 정수 50~75만 중에서 소수를 찾는다.
- CPU 4: 정수 75~100만 중에서 소수를 찾는다.

- 그러나 이렇게하면 CPU 0이 먼저 끝나고 CPU 4는 제일 나중에 끝날 것이다.

다음과 같이 이를 개선할 예정이다.

- 전역 변수 num을 만든다.
- 각 스레드는 num에서 값을 하나씩 가져온다. 가져온 값이 소수인지 판별한다.
- 소수면 배열 primes에 찾은 숫자를 출력한다.
- 모든 스레드가 일을 마치고 나면 소수를 출력한다.

![개선된 소수 찾기 프로그램](image-12.png)

- 실제 코드

```c++
#include <vector>
#include <iostream>
#include <chrono>   // 시간 측정을 위한 라이브러리
#include <thread>   // 스레드 생성을 위한 라이브러리
#include <memory>   // shared_ptr 사용을 위한 라이브러리

using namespace std;

const int MaxCount = 150000; // 조사할 숫자의 범위
const int ThreadCount = 4;   // 생성할 워커 스레드의 개수

bool IsPrimeNumber(int number)
{
    if (number = = 1)
        return false;
    if (number = = 2 || number = = 3)
        return true;
    for (int i = 2; i < number - 1; i++)
    {
        if ((number % i) = = 0)
            return false;
    }
    return true;
}

void PrintNumbers(const vector<int>& primes)
{
    for (int v : primes)
    {
        cout << v << endl;
    }
}

int main()
{
    // 각 스레드는 여기서 값을 꺼내 온다.
    int num = 1;

    // 발견된 소수들을 저장할 벡터
    vector<int> primes;

    auto t0 = chrono::system_clock::now();

    // 작동할 워커 스레드
    vector<shared_ptr<thread> > threads;

    for (int i = 0; i < ThreadCount; i++)
    {
        // shared_ptr을 사용하여 스레드 객체 생성
        // [&] : 람다 함수 외부의 변수(num, primes 등)를 참조로 가져온다
        shared_ptr<thread> thread(new thread([&]() {
            // 각 스레드의 메인 함수
            // 값을 가져올 수 있으면 루프를 돈다.
            while (true)
            {
                int n;
                n = num;
                num++;

                if (n >= MaxCount)
                    break;

                if (IsPrimeNumber(n))
                {
                    primes.push_back(n);
                }
            }
        }));
        // 스레드 객체를 일단 갖고 있는다.
        threads.push_back(thread);
    }

    // 모든 스레드가 일을 마칠 때까지 기다린다.
    for (auto thread : threads)
    {
        thread->join();
    }
    // 끝

    auto t1 = chrono::system_clock::now();

    auto duration = chrono::duration_cast<chrono::milliseconds>(t1 - t0).count();
    cout << "Took " << duration << " milliseconds." << endl;

    // PrintNumbers(primes);

    return 0;
}
```

- 프로그램을 실행하면 다음과 같은 오류가 발생한다.
  ![무작정 시도한 멀티스레드 프로그래밍 오류](image-13.png)
