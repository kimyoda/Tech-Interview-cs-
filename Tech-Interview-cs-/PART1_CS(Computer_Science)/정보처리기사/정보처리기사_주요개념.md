# 🌐 정보처리기사(2024 정리)

## 1 소프트웨어 설계와 개발 방법론

### 1-1. 데이터흐름도

- 데이터 흐름도는 시스템의 데이터 흐름과 처리를 시각화하는 도구, 네가지 기본 요소로 구성된다.
- 프로세스(데이터를 변화하는 작업)
- 데이트 허름(데이터가 이동하는 경로)
- 데이터 저장소/창고(데이터가 일시적으로 저장되는 곳)
- 종단점(터미네이터, 시스템 외부의 발신자/수신자)를 사용하여 시스템을 표현한다.

### 1-2. UML 다이어그램
* 정적 구조를 나타내는 다이어그램 - UML은 소프트웨어 구조와 동작을 시각적으로 표현하기 위한 표준이다.
  - 클래스 다이어그램은 클래스, 속성, 메서드 및 클래스 간 관계를 보여준다
  - 컴포넌트 다이어그램은 소프트웨어 컴포넌트와 인터페이스 간의 의존성을 모델링한다.
  - 배치 다이어그램은 하드웨어 노드와 소프트웨어가 어떻게 배치되는지 표현한다.
* 동적 동작을 나타내는 다이어그램
  - UML의 행위 다이어그램은 시스템의 시간적 흐름을 보여준다.
  - 상태(state)다이어그램은 객체가 시간에 따라 가질 수 있느 상태와 상태 간 전이를 표현한다.
  - 활동다이어그램은 시스템이나 프로세스의 제어 흐름과 병행 활동을 나타낸다.

### 1.3 설계원칙 - SOLID
- 객체지향 설계에서 널리 사용하는 원칙이다.
| 원칙 (약어) | 전체 이름 | 설명 및 중요성 |
| :--- | :--- | :--- |
| **SRP** | Single Responsibility Principle | 하나의 클래스는 하나의 책임만 가져야 한다. 즉, 변경의 이유는 하나여야 한다. 이렇게 하면 클래스가 유지보수하기 쉬워지고 테스트하기 쉽다. |
| **OCP** | Open–Closed Principle | 소프트웨어 요소는 확장에는 열려 있고 수정에는 닫혀 있어야 한다. 새로운 기능을 추가할 때 기존 코드를 변경하지 않고 확장할 수 있어야 한다. |
| **LSP** | Liskov Substitution Principle | 상속받은 하위 타입은 언제나 기반 타입으로 대체할 수 있어야 한다. 즉, 기반 클래스가 사용되는 곳에서 하위 클래스도 문제 없이 동작해야 한다. |
| **ISP** | Interface Segregation Principle | 특정 클라이언트가 사용하지 않는 인터페이스에 의존하도록 강요해서는 안 된다. 여러 개의 구체적인 인터페이스로 분리해 필요 없는 의존성을 줄여야 한다. |
| **DIP** | Dependency Inversion Principle | 구체적인 것보다 추상적인 것에 의존해야 한다. 상위 수준 모듈이 하위 수준 모듈의 세부 구현에 직접 의존하면 안 되며, 추상화를 통해 결합을 약하게 해야 한다. |

### 1.4 디자인 패턴
* FactoryMethod(팩토리 메서드) 
  - 객체를 생성하는 인터페이스는 유지하되 실제 생성되는 구체적인 타입은 서브클래스에서 결정할 수 있게 하는 생성 패턴이다. 객체 생성 로직을 분리해 코드 의존성을 낮춘다.

* Prototype(프로토타입)
  - 기존 객체를 복사해 새로운 객체를 만드는 패턴으로, 클래스에 의존하지 않고 객체를 복사할 수 있게 된다. 초기화 비용이 높은 객체를 효율적으로 생성할 때 유용하다.

* Bridge(브리지)
  - 클래스의 추상 부분과 구현 부분을 분리해 독립적으로 확장할 수 있도록 하는 구조 패턴이다. 추상화 계층과 구체적인 구현 계층을 별도의 상속 구조로 분리한다.

* Mediator(중재자)
  - 객체들 간의 복잡한 의존 관계를 중재자 객체 하나에 캡슐화해 상호 의존성을 줄이는 패턴이다. 여러 객체 간의 통신을 중앙 집중화함으로써 결합도를 낮출 수 있다.

---

### 1-2. NestJS와 Express의 차이점은?

- **Express**는 웹 프레임워크로 자유도가 높으나 구조가 없어 큰 프로젝트에서는 복잡할 수 있다.
- NestJS는 정해진 아키텍처 패턴(모듈, 컨트롤러, 서비스)를 제공하고 TypeScript 기반으로 타입 안전성과 의존성 주입을 지원해 규모가 큰 애플리케이션 개발에 적합하다.

---

## 2. 구성 요소

### 2-1. NestJS 구성요소

- **Module**: 앱의 구조를 조직화하는 단위이고 관련된 컨트롤러와 서비스들을 그룹핑한다.
- **Controller**: HTTP 요청을 처리하고 응답을 반환하는 역할을 한다.
- **Service(Provider)**: 비즈니스 로직을 담당하고 다른 컴포넌트에 주입 가능한 클래스이다.
- **Middleware**: 요청/응답 사이클에 실행되는 함수들이다.

---

### 2-2 프로바이더(Provider)란?

- 프로바이더는 의존성 주입이 가능한 클래스이다. `@Injectable()`데코레이터가 붙은 서비스, 레포지토리, 팩토리, 헬퍼 등이 될 수 있다. NestJSIoC 컨테이너에 의해 관리하고, 생성자를 통해 다른 클래스에 주입된다.

---

## 3. 데코레이터

### 3-1. 주요 데코레이터와 역할을 설명해라.

- `@Module()`: 모듈을 정의하고 imports, controllers, providers 등을 설정한다.
- `@Controller()` : HTTP 엔드포인트를 처리하는 클래스를 정의한다.
- `@Injectable()`:의존성 주입 가능한 프로바이더로 마킹한다.
- `@Get()`, `@Post()`, `@Put()`, `@Delete()`: HTTP 메서드를 매핑한다.

### 3-2. `@Injectable()` 데코레이터의 역할?

- `@Injectable()` 데코레이터는 클래스가 의존성 주입 시스템에 참여할 수 있도록 메타데이터를 추가한다.
- 데코레이터가 있어야 NestJS IoC 컨테이너가 해당 클래스의 인스턴스를 생성하고 다른 클래스에 주입할 수 있다.

---

## 4. 모듈 시스템

### 4-1. 모듈이란?

- 모듈은 `@Module()` 데코레이터로 장식된 클래스, 애플리케이션 구조를 조직화한다. imports(다른 모듈 가져오기), controllers(컨트롤러 등록), providers(프로바이더 등록), exports(다른 모듈에 사용할 수 있도록 내보내기)속성을 가진다.

### 4-2. 전역모듈과 기능 모듈의 차이

- **기능 모듈**: 특정 기능에 관련된 컨트롤러와 서비스들을 그룹화
- **전역 모듈**: `@Global()` 데코레이터가 붙은 모듈, 한번 import 하면 애플리케이션 전체에서 사용이 가능하다.
- **공유 모듈**: exports 배열을 통해 다른 모듈에서 재사용할 수 있는 모듈

## 6. 요청 처리 흐름

### 6-1. HTTP 요청이 NestJS 처리

1. 미들웨어: 요청 전처리(로깅, CORS 등)
2. 가드(Guards): 인증 / 인가 검사
3. 인터셉터(Before)L 요처 데이터 변형
4. 파이프(Pipes): 데이터 검증 및 변환
5. 컨트롤러 핸들러: 실제 비즈니스 로직을 실행
6. 인터셉터(After): 응답 데이터 변형함
7. 필터(Exception Filters): 예외처리
8. 응답 반환

---

## 7. 파이프(Pipes)

### 파이프란?

- 파이프는 데이터 검증과 변환을 담당하는 컴포넌트다.
- 컨트롤러 핸들러가 실행되기 전 입력 데이터를 처리한다.
- 내장 파이프로 `ValidationPipe`, `ParseIntPipe` 등이 있다.
- DTO와 class-validator를 함께 사용해 자동 검증이 가능하다.

---

## 8. DTO(Data Transfer Object)란?

- **DTO**는 계층 간 데이터 전송을 위한 객체이다.
- TypeScript 타입 안정성을 제공, class-validator 데코레이터와 함께 사용해 입력 데이터 검증을 자동화할 수 있다.
- API 문서화와 런타임 검증을 동시에 제공한다.

## 9. 기본 설정 및 환경변수

### 9.1 NestJS에서 환경변수를 어떻게 처리하나

- `@nestjs/config` 패키지를 사용해 환경변수를 관리한다.
- ConfigModule을 루트 모듈에 import하고, ConfigService를 주입받아 환경변수에 접근할 수 있다.
- .envㅠㅏ일과 validate 함수를 통해 환경변수 검증도 가능하다.
