# 🌐 정보처리기사(2024 정리)

## 1 소프트웨어 설계와 개발 방법론

### 1-1. 데이터흐름도

- 데이터 흐름도는 시스템의 데이터 흐름과 처리를 시각화하는 도구, 네가지 기본 요소로 구성된다.
- 프로세스(데이터를 변화하는 작업)
- 데이트 허름(데이터가 이동하는 경로)
- 데이터 저장소/창고(데이터가 일시적으로 저장되는 곳)
- 종단점(터미네이터, 시스템 외부의 발신자/수신자)를 사용하여 시스템을 표현한다.

### 1-2. UML 다이어그램
* 정적 구조를 나타내는 다이어그램 - UML은 소프트웨어 구조와 동작을 시각적으로 표현하기 위한 표준이다.
  - 클래스 다이어그램은 클래스, 속성, 메서드 및 클래스 간 관계를 보여준다
  - 컴포넌트 다이어그램은 소프트웨어 컴포넌트와 인터페이스 간의 의존성을 모델링한다.
  - 배치 다이어그램은 하드웨어 노드와 소프트웨어가 어떻게 배치되는지 표현한다.
* 동적 동작을 나타내는 다이어그램
  - UML의 행위 다이어그램은 시스템의 시간적 흐름을 보여준다.
  - 상태(state)다이어그램은 객체가 시간에 따라 가질 수 있느 상태와 상태 간 전이를 표현한다.
  - 활동다이어그램은 시스템이나 프로세스의 제어 흐름과 병행 활동을 나타낸다.

### 1.3 설계원칙 - SOLID
- 객체지향 설계에서 널리 사용하는 원칙이다.
| 원칙 (약어) | 전체 이름 | 설명 및 중요성 |
| :--- | :--- | :--- |
| **SRP** | Single Responsibility Principle | 하나의 클래스는 하나의 책임만 가져야 한다. 즉, 변경의 이유는 하나여야 한다. 이렇게 하면 클래스가 유지보수하기 쉬워지고 테스트하기 쉽다. |
| **OCP** | Open–Closed Principle | 소프트웨어 요소는 확장에는 열려 있고 수정에는 닫혀 있어야 한다. 새로운 기능을 추가할 때 기존 코드를 변경하지 않고 확장할 수 있어야 한다. |
| **LSP** | Liskov Substitution Principle | 상속받은 하위 타입은 언제나 기반 타입으로 대체할 수 있어야 한다. 즉, 기반 클래스가 사용되는 곳에서 하위 클래스도 문제 없이 동작해야 한다. |
| **ISP** | Interface Segregation Principle | 특정 클라이언트가 사용하지 않는 인터페이스에 의존하도록 강요해서는 안 된다. 여러 개의 구체적인 인터페이스로 분리해 필요 없는 의존성을 줄여야 한다. |
| **DIP** | Dependency Inversion Principle | 구체적인 것보다 추상적인 것에 의존해야 한다. 상위 수준 모듈이 하위 수준 모듈의 세부 구현에 직접 의존하면 안 되며, 추상화를 통해 결합을 약하게 해야 한다. |

### 1.4 디자인 패턴
* FactoryMethod(팩토리 메서드) 
  - 객체를 생성하는 인터페이스는 유지하되 실제 생성되는 구체적인 타입은 서브클래스에서 결정할 수 있게 하는 생성 패턴이다. 객체 생성 로직을 분리해 코드 의존성을 낮춘다.

* Prototype(프로토타입)
  - 기존 객체를 복사해 새로운 객체를 만드는 패턴으로, 클래스에 의존하지 않고 객체를 복사할 수 있게 된다. 초기화 비용이 높은 객체를 효율적으로 생성할 때 유용하다.

* Bridge(브리지)
  - 클래스의 추상 부분과 구현 부분을 분리해 독립적으로 확장할 수 있도록 하는 구조 패턴이다. 추상화 계층과 구체적인 구현 계층을 별도의 상속 구조로 분리한다.

* Mediator(중재자)
  - 객체들 간의 복잡한 의존 관계를 중재자 객체 하나에 캡슐화해 상호 의존성을 줄이는 패턴이다. 여러 객체 간의 통신을 중앙 집중화함으로써 결합도를 낮출 수 있다.

### 1.5 극단적 프로그래밍
- XP는 애자일 방법론 중 하나로 짧은 주기로 지속적인 개선과 피드백을 강조한다. 
- 주요 원칙으로는 작동하는 소프트웨어가 진척도 측정의 핵심,작은 단위의 빠른 반복과 고객의 지속적 참여, 단순한 설계와 지속적인 리팩터링, 페어 프로그래밍과 코드 리뷰, 테스트 주도 개발 등이 있다.

### 1.6 HIPO와 CASE
  * **HIPO(Hierachical Input-Process-Output)** 
    - 1970년대 IBM에서 제안한 설계 및 문서화 기법이다. 시스템의 모듈을 계층적으로 표현하는 구조도와 모듈별로 입력,처리,출력 정보를 기술한 IPO 차트로 구성된다. HIPO는 시스템 설계를 계층 구조로 정리하고 각 모듈의 기능과 데이터 흐름을 명확히 문서화하는데 사용된다.
  * **CASE(Computer-Aided Software Engineering)**
    - 소프트웨어 개발 전 과정을 컴퓨터 도구로 자동화해 품질과 생산성을 높이려는 접근이다. CASE는 시스템 개발의 각 단계에서 문서 작성, 분석, 설계, 코드 생성, 테스트를 지원, 고품질, 결점 최소화를 목표로 한다. 
    - CASE 도구에는 다이어그램 작성, 분석 검사, 저장소, 문서 생성, 코드 생성 등의 기능이 포함된다.

### 1.7 비기능 요구사항
 - 비기능 요구사항은 시스템의 품질 특성을 정의한다.
 - 비기능 요구사항은 실행품질(안전성, 보안, 사용성)과 진화 품질(테스트 용이성, 유지보수성, 확장성)으로 구분되고, 일반적으로 성능, 신뢰성/가용성/안전성, 확장성, 테스트 용이성 등이 포함된다. 
 - 시험에는 비기능 요구사항의 예시를 묻는 문제가 많다.

### 1.8 소프트웨어 테스트
  * 블랙박스 테스트
    - 소프트웨어 내부 구조를 고려하지 않고 기능과 요구사항만을 검증하는 방법이다. 설계 및 코드를 알 필요가 없고, 요구사항을 기반으로 입력과 기대 결과를 확인한다.
    - 기능 테스트, 회귀 테스트, 비기능 테스트에서 사용된다.
  * 화이트박스 테스트
    - 소프트웨어의 내부 로직과 코드 구조를 이해, 흐름 제어, 데이터 흐름 등을 바탕으로 테스트 케이스를 설계하는 방법이다.
    - 개발자가 단위 수준에서 코드의 정확성과 효율성을 검증하는 데 사용되고, 제어 흐름 테스트나 데이터 흐름 테스트와 같은 기법을 활용한다.
  * 테스트 오라클
    - 출력이 올바른지 판단하기 위해 기대 결과를 미리 제공하는 메커니즘이다. 시험에서 참 오라클(장답), 휴리스틱 오라클(규칙 기반), 일관성 검사 오라클(다른 버전과 비교) 등 유형을 물어볼 수 있다.
---

## 2. 소프트웨어 개발과 자료구조 / 알고리즘

### 2.1 정렬 알고리즘
  * **버블 정렬(Bubble Sort)**
    - 인접한 두 원소를 비교해 순서가 틀리면 교환하는 방식으로 리스트를 여러 번 반복하며 정렬한다. 알고리즘은 구현이 간단하나, 시간 복잡도는 O(n2)로 효율적이지 않다.
    - 안정 정렬이며 주로 교육용 예제이다.
  
  * **선택 정렬(Selection Sort)**
    - 남아 있는 요소 중 가장 작은 요소를 선택해 앞쪽부터 채워나가는 방식으로 정렬한다.
    - 교환 횟수가 적지만 마찬가지로 O(n2)의 시간 복잡도를 가진다.

  * **삽입 정렬(Insertion Sort)**
    - 이미 정렬된 부분 배열에 새 요소를 적절한 위치에 삽입하는 방식이다.
    - 데이터가 거의 정렬되어 있을 때 빠른 성능을 보이고, 안정 정렬이다.

  * **퀵 정렬(Quick Sort)**
    - 기준(피벗)을 선택한 뒤 피벗보다 작은 요소와 큰 요소로 분할하여 재귀적으로 정렬한다.
    - 평균적으로 O(n log n)의 시간 복잡도를 가진 빠른 정렬법이지만, 피벗 선택에 따라 최악의 경우 O(n2)까지 느려질 수 있다.

  * **병합 정렬(Merge Sort)**
    - 배열을 절반씩 분할한 뒤 각 부분을 정렬하고 병합하는 방식이다.
    - 안정적이고 최악, 최선 모두 O(n log n)의 시간 복잡도를 갖는다. 추가적인 메모리 공간이 필요하다.

### 2.2 자료구조와 연산
  * **스택과 큐** 
    - 스택(Stack)은 LIFO(Last In, First Out)방식으로 push/pop 연산을, 큐(Queue)는 FIFO(First In, First Out)방식으로 enqueue/dequeue 연산을 수행한다.
    - 우선순위 큐는 요소에 우선순위를 부여하여 높은 우선순위 요소를 먼저 꺼낸다.
  
  * **트리와 그래프**
    - 트리는 순환이 없는 계층적 구조, 이진 트리, 이진 탐색 트리(BST), 힙(heap)등이 자주 다뤄진다.
    - 그래프는 정점과 간선으로 구성, DFS/BFS 탐색, 최단 경로 알고리즘 등이 시험에 등장할 수 있다.

  * **해시 구조**
    - 해시 함수로 키를 해시 테이블의 인덱스로 변환해 데이터 O(1)로 접근할 수 있게 해준다.
    - 충돌 해결 방법(체이닝, 개방 주소법 등) 부하율 개념을 이해해야 한다.

---

## 3. 데이터 베이스

### 3.1 관계형 데이터 모델과 키