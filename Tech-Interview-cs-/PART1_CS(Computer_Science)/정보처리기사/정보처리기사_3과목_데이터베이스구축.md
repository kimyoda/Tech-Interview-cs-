# 🌐 정보처리기사

## 3. 데이터베이스 구축

1. 데이터베이스 설계 순서.
   - 요구 조건 분석(요구 조건 명세서 작성)
   - 개념적 설계(개념 스키마, 트랜잭션 모델링, E-R 모델)
   - 논리적 설계(목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계)
   - 물리적 설계(목표 DBMS에 맞는 물리적 구조의 데이터로 변환)
   - 구현(목표 DBMS의 DDL - 데이터 정의어, 데이터 베이스 생성, 트랜잭션 작성)

2. 개념적 설계
   - 개념적 설계란 정보의 구조를 얻기 위해 현실 세계의 무한성ㄹ과 계속성을 이해, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다.
     - 개념적 설계 단계에서 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다.
     - 개념적 설계 단계에서 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성한다.
     - dbms에 독립적인 개념 스키마를 설계한다.

3. 논리적 설계(데이터 모델링)
   - 논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료구조로 변환시키는 과정이다.
     - 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.
     - 개념적 설계가 개념 스키마를 설계하는 단계면 논리적 설계에서 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
     - 트랜잭션의 인터페이스를 설계한다.
     - 관계형 데이터베이스면 테이블을 설계하는 단계이다.

4. 물리적 설계(데이터 구조화)
   - 물리적 설계란 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
     - 물리적 설계 단게에서 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.
     - 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.
     - 물리적 설계 시 고려할 사항: 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간의 효율화 등 

5. 데이터 모델
   - 데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형이다.
     - 개체(Entitiy): 데이터베이스에 표현하려는 것, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
     - 속성(Attribute): 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다
     - 관계(Relationship): 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미한다.
     - 구조(Structure): 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현한다.
     - 연산(Operation): 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
     - 제약 조건(Constraint): 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

6. 관계의 형태
   - 관계의 형태에는 일 대 일(1:1), 일 대 다 (1:N), 다 대 다 (N:M)관게가 있다.
   - 일 대 일(1:1): 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
   - 일 대 다(1:N): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있으나, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
   - 다 대 다(N:M): 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계

7. E-R 모델 개요
   - E-R 모델은 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터첸에 의해 제안되고 기본적인 구성 요소가 정립되었다.
   - E-R 모델은 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현한다.
   - E-R 모델에서는 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다.
   - E-R 모델은 특정 DBMS를 고려한 것은 아니다.
   - E-R 다이어그램으로 표현, 1:1, 1:N, N:M 등의 관계 유형을 제한없이 나타낼 수 있다.

8. E-R 다이어그램
   | 기호 (형태) | 기호 이름 | 의미 |
| :---: | :--- | :--- |
| **▭** (직사각형) | **사각형** | 개체(Entity) 타입 |
| **◇** (마름모) | **마름모** | 관계(Relationship) 타입 |
| **○** (타원) | **타원** | 속성(Attribute) |
| **◎** (이중 타원) | **이중 타원** | 다중값 속성(복합 속성) |
| **<u>○</u>** (밑줄 타원) | **밑줄 타원** | 기본키(Primary Key) 속성 |
| **o-o-o** (연결된 타원) | **복수 타원** | **복합 속성**<br>*(예: 성명은 성과 이름으로 구성)* |
| **1-◇-N** | **관계** | 1:1, 1:N, N:M 등의 개체 간 관계에 대한 대응수를 선 위에 기술함 |
| **────** | **선, 링크** | 개체 타입과 속성을 연결 |

9.  관계형 데이터베이스의 Relation 구조
   - 릴레이션은 데이터들을 표의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키미와 실제 값들인 릴레이션 인스턴스로 구성된다.
   | 용어 | 설명 | 이미지 내 위치 |
| :--- | :--- | :--- |
| **릴레이션 (Relation)** | 데이터들을 표(Table) 형태로 표현한 것 (스키마 + 인스턴스) | 전체 표 |
| **속성 (Attribute)** | 데이터베이스를 구성하는 가장 작은 논리적 단위 (열, Column) | 맨 윗줄 (학번, 이름 등) |
| **튜플 (Tuple)** | 속성들의 모임으로 구성된 각각의 행 (Row) | 가로 한 줄 (데이터 1건) |
| **도메인 (Domain)** | 하나의 속성이 가질 수 있는 같은 타입의 원자값들의 집합 | '학년' 열의 값 범위 |
| **릴레이션 스키마** | 릴레이션의 이름과 속성 이름들의 집합 (테이블 구조) | 헤더 부분 (제목 행) |
| **릴레이션 인스턴스** | 어느 시점에 릴레이션에 실제 저장되어 있는 튜플들의 집합 | 데이터 부분 (내용) |

   - 튜플(Tuple)
     - 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
     - 튜플은 속성의 모임으로 구성된다.
     - 파일 구조에서 레코드와 같은 의미이다.
     - 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수라고 한다.
   - 속성(Attribute)
     - 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
     - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당된다.
     - 속성은 개체의 특성을 기술한다.
     - 속성의 수를 디그리 또는 차수라고 한다. 
   - 도메인(Domain)
     - 도메인은 하나의 에트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합이다.
     - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에 이용된다.   

10.  릴레이션 특징
   - 한 릴레이션에 똑같은 튜플이 포함될 수 없고 릴레이션에 포함된 튜플들은 모두 상이하다.
   - 한 릴레이션에 포함된 튜플 사이에 순서가 없다.
   - 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
   - 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
   - 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.   
   - 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다.
   - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.

11. 무결성(Integrity)
  - 무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다.
  - 개체 무결성(Entity, Integrity, 실체 무결성): 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 갑시안 중복값을 가질 수 없다는 규정이다.
  - 도메인 무결성(Dormain Integrity, 영역 무결성):  주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정이다
  - 참조 무결성(Referential Integrity): 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
  - 사용자 정의 무결성(User-Defined Integrity): 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정

12. 키(Key)
  - 키(Key)는 데이터베이스에 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다.
  - 후보키(Candidate Key)
    - 릴ㄹ레이션을 구성하는 속성들 중에 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합. 기본키로 사용할 수 있는 속성들을 말한다.
    - 후보키는 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.
  - 기본키(Primary Key)
    - 후보키 중에서 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없다
    - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
    - 기본키는 NULL 값을 가질 수 없다. 즉 튜플에서 기본키로 설정된 속성에 NULL 값이 있어서는 안된다.
  - 대체키(Alternate Key)
    - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다
    - 보조키라고도 한다.
  - 슈퍼키(Super Key)
    - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
    - 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.
  - 외래키(Foreign Key)
    - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들을 집합을 믜미한다
    - 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때 속성 A를 외래키라고 한다.   

13. 관계대수의 개요
  - 관계대수는 관계형 데이터베이스에 원하는 정보와 그 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적인 언어이다.
    - 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결과도 릴레이션이다.
    - 질의에 대한 해를 구하기 위해 수행해야할 연산의 순서를 명시한다.
    - 관계대수에 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.
    - 순수 관계 연산자
      - Select
      - Project
      - Join
      - Division
    - 일반 집합 연산자
      - UNION(합집합)
      - INTERSECTION(교집합)
      - DIFFERENCE(차집합)
      - CARTESIAN PRODUCT(교차곱) 

14. 순수 관계 연산자
  - Select: 릴레이션에 존재한느 튜플 중에 선택 조건을 만족하는 튜플의 부분집합을 구하는 새로운 릴레이션을 만드는 연산
    - 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고 한다
    - 연산자의 기호는 그리스 문자 시그마를 사용한다.
  - Project
    - 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이다. 단, 연산 결과에 중복이 발생하면 중복이 제거된다.
      - 릴레이션의 열에 해당하는 Atribute를 추출하는 것으로 수직 연산자라고도 한다
      - 연산자의 기호는 그리스 문자 파이를 사용한다
  - Join
    - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
      - 연산자의 기회는 ><를 사용한다
  - Division
    - $X \supset Y$인 두 개의 릴레이션 $R(X)$와 $S(Y)$가 있을 때, $R$의 속성이 $S$의 속성값을 **모두 가진 튜플**에서 $S$가 가진 속성을 제외한 속성만을 구하는 연산
      - 연산자의 기호는 $\div$를 사용함 

15. 일반 집합 연산자
  - 클래스 다이어그램(Class Diagram)
  - 객체 다이어그램(Obejct Diagram)
  - 컴포넌트 다이어그램(Componenet Diagram)
  - 배치 다이어그램(Deployment Diagram)
  - 복합체 구조 다이어그램(Composite Structure Diagram)
  - 패키지 다이어그램(Package Diagram)  

16. 정규화의 개요
  - 정규화란 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.
    - 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정이라 할 수 있다.
    - 정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형 등이 있고, 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다.
    - 정규화는 데이터베이스의 논리적 설계 단계에서 수행한다.
    - 정규화는 논리적 처리 및 품질에 큰 영향을 미친다.
    - 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안전성 등을 보장한다.

17. 정규화의 목적
  - 데이터 구조의 안전성 및 무결성을 유지한다.
  - 어떠한 릴레이션이라도 데이터베이스 내에 표현 가능하게 만든다.
  - 효과적인 검색 알고리즘을 생성할 수 있다.
  - 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능하다.
  - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
  - 데이터 모형의 단순화가 가능하다.
  - 속성의 배열 상태 검증이 가능하다. 
  - 개체와 속성의 누락 여부 확인이 가능하다.
  - 자료 검색과 추출의 효율성을 추구한다.

18. 이상(Anomaly)의 개념 및 종류
  - 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생, 이를 이상(Anomaly)이라 하고 삼입 이상, 삭제 이상, 갱신 이상이 있다.
  - 삽입 이상(Insertion Anomaly): 릴레이션에 데이터를 삽입할 때 의도완든 상관없이 원하지 않은 값들도 함께 삽입되는 현상
  - 삭제 이상(Deleteion Anomaly): 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상
  - 갱신 이상(Update Anomaly): 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

19. 정규화 과정
  - 비정규 릴레이션(도메인 원자값) -> 1NF(부분적 함수 종속 제거) -> 2NF(이행적 함수 종속 제거) -> 3NF(결정자이면서 후보키가 아닌 것 제거) -> BCNF(다치 종속 제거) -> 4NF(조인 종속성 이용) -> 5NF

20. 정규화 단계 암기 요령
  - 도메인이 원자 값
  - 부분적 함수 종속 제거
  - 이행적 함수 종속 제거
  - 결정자이면서 후보키가 아닌 것 제거
  - 다치 종속 제거
  - 조인 종속성 이용

21. 

22. 

23. 

24. 

25. 

26. 

27. 

28. 

29. 

30. 

31. 

32. 

33. 

34. 

35. 

36. 

37. 

38. 

39. 

40. 

41. 

42. 

43. 

44. 

45. 

46. 

47. 

48. 

49. 

50. 

51. 

52. 

53. 

54. 

55. 
