## 1. JPA, Mybatis 비교 및 질문정리

### 📌 JPA와 Mybatis란?

**JPA(Java Persistence API)**

- JAVA ORM(Object-Relational Mapping) 표준 기술
- 객체와 데이터베이스 테이블을 매핑하여 SQL을 자동으로 생성한다.
- Hibernate가 JPA의 대표적인 구현체이다.
- Spring Data JPA를 통해 Spring에서 기본적으로 사용이 가능하다.

**MyBatis**

- SQL Mapper 기술
- 개발자가 직접 SQL 쿼리를 작성, 그 결과를 객체에 매핑한다.
- XML 또는 어노테이션을 통해 SQL을 관리한다.

---

### 🔄 JPA vs MyBatis 주요 차이점

| 구분            | JPA                                      | MyBatis                              |
| :-------------- | :--------------------------------------- | :----------------------------------- |
| **기술 분류**   | ORM (Object-Relational Mapping)          | SQL Mapper                           |
| **SQL 작성**    | 자동 생성 (JPQL, Criteria API)           | 개발자가 직접 작성 (XML/Annotation)  |
| **개발 속도**   | 빠름 (기본 CRUD 자동화)                  | 상대적으로 느림 (쿼리 작성 필요)     |
| **개발 중심**   | 객체 지향적 개발 (Java 객체 중심)        | SQL 중심 개발 (DB 쿼리 중심)         |
| **복잡한 쿼리** | Native Query 또는 JPQL 필요              | 직접 제어 가능 (세밀한 튜닝 용이)    |
| **러닝 커브**   | 높음 (영속성 컨텍스트, N+1 등 이해 필요) | 낮음 (SQL 지식만 있으면 사용 가능)   |
| **유연성**      | 제한적 (DB 변경에는 유연함)              | 높음 (SQL 구조를 자유롭게 변경 가능) |

---

## 💡 JPA의 장단점

- 장점

  1. 생산성 향상: 반복적인 CRUD 쿼리를 작성하지 않아도 된다.
  2. 객체지향적 개발: 객체 중심으로 개발이 가능하다.
  3. 유지보수 용이: Entity 클래스만 수정하여 테이블 스키마 변경이 반영 가능하다.
  4. 데이터베이스 독립성: 특정 DB에 종속되지 않는다.
  5. 변경감지: 트랜잭션 내에서 객체 변경시 자동으로 업데이트 된다.

- 단점

1. 복잡한 쿼리 작성 어려움: 복잡한 조인 등은 Query 작성이 필요하다.
2. 성능최적화 어려움: 불필요한 쿼리가 발생할 수 있다.
3. 러닝 커브: 개념이해가 필요하다.
4. 예상치 못한 쿼리 발생: 의도하지 않은 업데이트가 발생할 수 있다.

## 💡 MyBatis의 장단점

- 장점

  1. SQL 직접 제어: 복잡한 쿼리를 자유롭게 작성이 가능하다.
  2. 성능 최적화 용이: 필요한 컬럼만 SELECT, 쿼리 수정이 가능하다.
  3. 낮은 러닝 커브: SQL 구문만 알면 사용이 가능하다.
  4. 동적 쿼리 작성: XML 태그를 활용하여 쿼리생성이 편하다.

- 단점
  1. 개발 생산성 저하: 모든 CRUD SQL을 그대로 사용해야 한다.
  2. 반복적인 코드: 유사한 SQL문을 여러 번 작성해야한다.
  3. 데이터베이스 종속성: DB 변경 시 SQL을 수정이 필요하다.
  4. 객체 지향적 개발 어려움: SQL 중심 개발로 도메인 모델 설계를 제한한다.

---

## 🎯 어떤 상황에 어떤 기술을 선택할까?

**JPA를 선택하는 경우**

- CRUD 중심의 비즈니스 로직이 필요한경우
- 빠른 개발이 필요한 경우
- 객체 지향적 설계를 중요한 경우
- 데이터베이스 변경 가능성이 있는 경우

**MyBatis를 선택하는 경우**

- 복잡한 쿼리가 많은 경우
- 성능 최적화가 중요한 경우
- 기존 SQL 자산을 활용해야 하는 경우

---

## 📝 면접 예상 질문(실제 질문) 및 답변

- Q1. JPA를 사용하면 어떤 방식으로 데이터베이스에 저장 했는 지?

  - 답변: JPA를 사용하여 데이터베이스에 저장할 때, Entity 클래스를 정의하고, 엔티티객체를 Repository를 통해 데이터베이스에 저장한다.
    Entity 클래스는 `@Entity`어노테이션으로 매핑하고, JPA는 엔티티 객체를 영속성 컨텍스트에 관리한다. `save()`메소드를 호출해서 INSERT나 UPDATE 쿼리를 자동으로 생성, 데이터베이스에 저장한다.
    다만, 의도치 않은 변경 사항이 반영될 수 있어 `@Transactional`어노테이션을 사용, 트랜잭션을 명시적으로 관리하는 것이 중요하다.

- Q2. JPA와 MyBatis의 차이점은 무엇이고, 어떤 기술이 더 괜찮았는 지?

  - 답변: 데이터베이스의 상호작용 방식에서 차이가 있다.
  - JPA는 ORM(Object-Relational Mapping)기술을 통한 객체지향 적 개발, 자바 객체를 데이터베이스 테이블과 매핑하여 SQL을 작성하지 않아도 데이터를 처리할 수 있다. 개발속도가 좀 빠르다는 장점이 있다.(SQl 직접 작성 x)
  - MyBatis는 SQL Mapper 기술로 SQL을 직접 작성하여 사용하는 방식이다. 복잡한 쿼리 작성이 필요할 때 유용하나 수동으로 작성해야 해서 작성 시간이 오래 걸릴 수 있다.
  - JPA는 기본적인 CRUD 작업을 신속 처리, 객체 중심의 개발을 선호할 때 유리하나 복잡한 쿼리를 작성해야 한다면 좀 더 어려운 작업을 해야한다.
  - MyBatis는 쿼리를 직접 컨트롤 할 수 있고 최적화나 복잡한 데이터 베이스를 구조를 다룰 때 나올 수 있다.

- Q3. JPA사용 시용 시 UPDATE할 때 다른 컬럼값이 사라질 수 있는 우려가 있다, 이에 대한 대응은?

  - 답변: JPA의 영속성 컨텍스트에 있는 엔티티 변경사항을 자동으로 감지, UPDATE 쿼리를 실행한다. 이떄 의도하지않은 필드까지 업데이트 될 수 있는 문제가 발생한 경우가 있었다.
  - indById()를 통해 수정할 엔티티를 영속성 컨텍스트로 조회한다.
  - 이후, 수정이 필요한 필드만 변경 메서드(Setter 등)를 통해 값을 바꾼다.
  - 랜잭션이 끝날 때 건드리지 않은 다른 필드들의 값은 그대로 유지되면서 안전하게 UPDATE가 수행된다.
  - 변경된 필드만 쿼리에 포함시키고 싶다면 @DynamicUpdate를 적용하여 쿼리 최적화를 할 수 있다.

- Q4. N+1 문제에 대한 해결은?
  - 답변: 연관된 엔티티를 조회할 때 쿼리가 갑자기 늘어나는 문제로, Fetch Join, Batch hSize 등을 통해 해결했다.
  - 리스트 조회나 전체 데이터를 가져오는 상황에서는 Fetch Join을 사용하여 쿼리를 줄였고, 연관된 데이터를 한번에 가져와서 해결하였다.
  - 페이징처리 등으로 처리ㅏㄹ 때는 Batch Size 옵션을 설정하여 IN절을 사용한 1번 쿼리로 묶어서 조회하여 페이징 기능을 유지하면서도 성능 최적화에 기여하였다.
