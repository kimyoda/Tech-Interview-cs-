# 🌐 리액트의 탄생과 생명주기

## 복잡한 UI를 위한 시도

- 2011년, 페이스북 엔지니어는 뉴스피드와 광고 관리 도구처럼 동적으로 변하는 UI를 효율적으로 유지할 수 있는 도구를 만들고자 했다.
- 2013년 5월 JSConf US에서 오픈 소스로 공개되며 개발자 커뮤니티에 급속히 확산되었다.
- 리액트는 2015년 리액트 네이티브, 2017년 리액트 Fiber 렌더러, 2022년 리액트 18 등 업데이트를 거쳐 지속적으로 발전하고 있다.

## 새 도구가 필요한 이유?

- 프론트엔드 개발 초기에 DOM을 직접 조작하는 방식이 일반적이었다. 그러나 요소가 많고 상태가 자주 바뀌는 애플리케이션에 다음과 같은 문제가 발생했다.
  - 코드가 복잡하고 유지보수가 어렵다 - 여러 DOM 요소를 선택하고 갱신하는 로직이 분산되면 버그가 발생하기 쉽다.
  - 성능 저하 -> DOM은 브라우저 내부 자료구조이기 때문에 업데이트가 많으면 리플로우(Reflow)와 리페인트(Repaint)가 자주 일어나고 렌더링 속도가 느려진다.
  - 상태와 UI의 불일치 -> 개발자가 여러 부분을 직접 업데이트 하는 과정에서 UI가 실제 상태와 다른 값으로 표현될 수 있다.

- 리액트는 Virtual DOM이라는 개념을 도입했다. UI의 이상적인 표현을 메모리에 저장, React DOM과 같은 라이브러리가 그 표현을 실제 DOM과 동기화하는 방식이다.
- 선언적 API를 이용해 원하는 UI 상태를 선언하면 리액트가 내부적으로 필요한 DOM 업데이트만 수행한다.
- 개발자는 일관된 UI를 유지할 수 있다.

## 라이브러리? 프레임워크?

- 리액트는 흔히 JavaScript UI 라이브러리로 안내한다. 기능을 살펴보면 프레임워크와 비슷하면도 있다.

| 구분           | 특징                   | 설명                                                                                                               |
| :------------- | :--------------------- | :----------------------------------------------------------------------------------------------------------------- |
| **라이브러리** | 특정 기능 제공         | 개발자가 필요한 기능만 가져다 사용합니다. 제어 흐름을 개발자가 관리합니다.                                         |
| **프레임워크** | 애플리케이션 구조 제공 | 프레임워크가 제어 흐름을 담당하고, 개발자는 규칙에 따라 코드를 작성합니다. Inversion of Control(IoC)이 적용됩니다. |

- 라이브러리는 개발자가 호출하여 사용, 프레임워크는 스스로 제어 흐름을 관리한다.
- 리액트에서는 개발자가 컴포넌트를 만들고 `ReactDOM`을 호출해 렌더링을 시작히게 라이브러리적 특성을 가진다.
- 상태 관리와 생명주기 처리 같은 기능을 내부적으로 제공, 이를 통해 애플리케이션의 구조와 흐름을 관리한다는 점에서 프레임 워크적 셩격도 있긴하다.
- 그렇지만, 리액트는 프레임워크의 특징을 가진 라이브러리이다. UI를 그리는 라이브러리에, 다양한 생태계 도구(라우팅, 상태관리, 서버 컴포넌트 등)와 결합하여 프레임워크와 같이 사용이 가능하다.

## 리액트 컴포넌트와 생명주기

- 컴포넌트라는 독립적이고 재사용 가능한 블록으로 구성된다.
- 컴포넌트에는 **상태(state)**와 **프록스(props)**가 있고, 상태가 변경되면 컴포넌트가 다시 렌더링된다.
- 이 과정에서 컴포넌트 생명주기(lifecycle) 메서드가 호출된다.

### 클래스 컴포넌트의 생명주기

- 클래스 기반 컴포넌트에서 생명주기 메서드를 명시적으로 구현한다.
  1. 마운트(Mounting): `constructor`에서 초기 state를 설정, `render()`를 호출하여 DOM에 삽입된다.
  2. 컴포넌트가 DOM에 삽입된 : `componentDidMount()`가 호출되어 타이머 설정이나 데이터 요청 같은 초기 작업을 수행할 수 있다.
  3. 업데이트(Updating): props 또는 state가 변경될때 마다 `render()`가 호출, DOM이 업데이트 된 후 `componentDidUpdate()`가 실행된다.
  4. 언마운트(Unmounting): 컴포넌트가 화면에서 제거 될 때 `componentWillUnmount()`가 호출되어 리소스를 정리한다.

```jsx
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() };
  }

  componentDidMount() {
    // 컴포넌트가 DOM에 삽입된 직후 실행
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    // 컴포넌트가 DOM에서 제거될 때 실행
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({ date: new Date() });
  }

  render() {
    return (
      <div>
        <h1>현재 시각:</h1>
        <h2>{this.state.date.toLocaleTimeString()}</h2>
      </div>
    );
  }
}
```

### 함수형 컴포넌트와 Hooks

- 리액트에서 함수형 컴포넌트와 Hooks를 사용해 생명주기 로직을 구현한다.
- `useEffect` Hook은 클래스 컴포넌트의 `componentDidMount`, `componentDidUpdate`, `componentWillUnmoun`를 하나로 합쳐 효과를 등록하고 정리하는 역할을 한다.
- 공식문서는 다음과 같이 설명한다.
  1. 컴포넌트는 화면에 추가될 때 마운트되고, 상태나 props가 바뀌면 업데이트 되고, 화면에서 제거되면 언마운트 된다.
  2. `useEffect`는 컴포넌트와느 다른 생명주기를 갖는다. effect는 동기화를 시작하고 나중에 동기화를 중지하는 두 가지 작업만 수행할 수 있고, 이는 의존성 배열에 따라 여러 번 발생할 수 있다.
  3. effect는 외부 시스템을 현재 props와 state에 동기화하는 방법을 나타내고, 반환값으로 cleanup 함수를 제공하여 연결을 해제한다.

### 정리

- 리액트는 복잡한 UI를 관리하기 위해 페이스북을 기점으로 생성된 라이브러리이다. Virtual DOM을 통한 선언적 렌더링과 컴포넌트 기반 아키텍처는 프론트엔드 개발을 발전시켰다.
- 리액트는 개발자가 필요한 부분만 사용하도록 설계된 라이브러리에 상태관리, 라우팅, 서버 컴포넌트 등 풍부한 생태계도 존재한다.
- 클래스 컴포넌트의 생명주기 메서드(`componentDidMount`, `componenetWillUnmount` 등)
- 함수형 컴포넌트에서의 `useEffect`등은 UI가 등장하고 사라지는 과정을 제허는 핵심 도구이다.
- 차후에 `useEffect`를 비롯한 다양한 Hook, 다양한 상태 관리 도구 등에 대해 다뤄 볼 예정이다.
