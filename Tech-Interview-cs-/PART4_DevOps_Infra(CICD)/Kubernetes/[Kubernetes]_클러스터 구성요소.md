# 🌐 쿠버네티스(Kubernetes) 클러스터 구성요소

## 📋 목차

- [클러스터란 무엇인가?](#클러스터란-무엇인가)
- [클러스터의 두 가지 핵심 노드](#클러스터의-두-가지-핵심-노드)
- [마스터 노드 (Control Plane)](#마스터-노드-control-plane)
- [워커 노드 (Worker Node)](#워커-노드-worker-node)
- [실제 동작 예시](#실제-동작-예시)

---

## 🏗️ 클러스터란 무엇인가?

**쿠버네티스 클러스터**는 여러 대의 컴퓨터(노드)를 하나의 통합된 시스템으로 묶어서 관리하는 구조입니다.

### 💡 쉽게 이해하기

- **개별 컴퓨터** → 각각 독립적으로 동작하는 개인용 PC
- **클러스터** → 여러 대의 PC를 연결해서 하나의 슈퍼컴퓨터처럼 만든 것
- **목적** → 대용량 애플리케이션을 안정적이고 효율적으로 운영

### 🔄 역할 분담 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    쿠버네티스 클러스터                      │
├─────────────────────────────────┬───────────────────────────┤
│        마스터 노드              │        워커 노드들        │
│      (Control Plane)           │     (Worker Nodes)        │
│      - 관리자 역할             │      - 실행 담당          │
│      - 지휘/조율              │      - 실제 서비스         │
└─────────────────────────────────┴───────────────────────────┘
```

---

## 👨‍💼 마스터 노드 (Control Plane) - 클러스터의 두뇌

마스터 노드는 전체 클러스터를 관리하고 제어하는 **관리자 역할**을 담당합니다.

### 🧠 핵심 구성 요소들

#### 1. **API 서버 (kube-apiserver)** - 클러스터의 입구

- **역할**: 모든 요청의 진입점
- **동작**: `kubectl` 명령어를 받아서 처리
- **통신**: 모든 구성 요소들이 API 서버를 통해 서로 소통
- **예시**: "웹서버 3개 실행해줘" → API 서버가 이 요청을 받음

#### 2. **데이터 저장소 (etcd)** - 클러스터의 기억력

- **역할**: 클러스터의 모든 상태 정보를 저장하는 분산 데이터베이스
- **저장 정보**:
  - 어떤 애플리케이션이 어느 서버에서 실행 중인지
  - 각 애플리케이션의 설정 정보
  - 클러스터 운영에 필요한 모든 메타데이터
- **중요성**: etcd가 없으면 클러스터가 "기억을 잃어버림"

#### 3. **스케줄러 (kube-scheduler)** - 배치 전문가

- **역할**: 어느 워커 노드에 애플리케이션을 배치할지 결정
- **고려 사항**:
  - 각 노드의 CPU/메모리 사용량
  - 애플리케이션의 요구사항
  - 노드의 상태와 정책
- **예시**: "웹서버는 CPU가 여유로운 노드에, DB는 메모리가 많은 노드에"

#### 4. **컨트롤러 매니저 (kube-controller-manager)** - 상태 관리자

- **역할**: 클러스터의 상태를 지속적으로 모니터링하고 조정
- **동작 방식**:
  - 원하는 상태 vs 현재 상태를 비교
  - 다르면 자동으로 맞추는 작업 수행
- **예시**: "웹서버 3개 있어야 하는데 1개가 죽었네? → 자동으로 1개 더 생성"

---

## 👷‍♂️ 워커 노드 (Worker Node) - 실제 실행 담당

워커 노드는 실제 애플리케이션 컨테이너들이 실행되는 **실행 공간**입니다.

### 🚀 핵심 구성 요소들

#### 1. **kubelet** - 노드의 관리자

- **역할**: 워커 노드에서 실행되는 에이전트
- **주요 업무**:
  - 마스터 노드로부터 지시사항 받기
  - 컨테이너 시작/중지/재시작
  - 컨테이너 상태 주기적 체크
  - 마스터 노드에 상태 보고
- **비유**: 마스터 노드의 "현장 감독관"

#### 2. **kube-proxy** - 네트워킹 담당

- **역할**: 서비스 간 통신과 외부 트래픽 처리
- **주요 기능**:
  - 서비스 간 통신 가능하게 하기
  - 외부 요청을 적절한 컨테이너로 전달
  - 로드 밸런싱
- **비유**: "교통 정리하는 교통경찰"

#### 3. **컨테이너 런타임** - 실제 실행 엔진

- **역할**: 컨테이너를 실제로 실행하는 소프트웨어
- **주요 종류**:
  - **Docker**: 가장 널리 사용됨
  - **containerd**: Docker에서 분리된 런타임
  - **CRI-O**: 경량화된 런타임
- **비유**: "컨테이너를 띄우는 엔진"

---

## 🔄 실제 동작 예시

### 📝 시나리오: "웹서버 3개 실행해줘"

#### 1단계: 요청 접수

```
사용자: kubectl run webserver --replicas=3
        ↓
    API 서버가 요청 받음
```

#### 2단계: 계획 수립

```
API 서버 → etcd에 요청 정보 저장
        → 스케줄러에게 "3개 배치 계획 세워줘" 요청
```

#### 3단계: 배치 결정

```
스케줄러: "노드A에 1개, 노드B에 2개 배치하자"
        (각 노드의 리소스 상황 고려)
```

#### 4단계: 실행 지시

```
API 서버 → 각 워커 노드의 kubelet에게 실행 명령
```

#### 5단계: 실제 실행

```
각 kubelet → 컨테이너 런타임으로 웹서버 컨테이너 실행
kube-proxy → 네트워크 설정으로 외부 접근 가능하게 함
```

#### 6단계: 상태 모니터링

```
컨트롤러 매니저: "3개 모두 실행되었나?" 지속 체크
kubelet: 각 컨테이너 상태를 주기적으로 마스터에 보고
```

---

## 💡 핵심 포인트 정리

### 🎯 마스터 노드의 핵심

- **API 서버**: 모든 요청의 입구
- **etcd**: 클러스터의 기억력
- **스케줄러**: 최적 배치 결정
- **컨트롤러**: 상태 자동 조정

### 🎯 워커 노드의 핵심

- **kubelet**: 현장 실행 담당
- **kube-proxy**: 네트워킹 담당
- **컨테이너 런타임**: 실제 실행 엔진

### 🔑 전체 동작 원리

1. **사용자 요청** → API 서버
2. **계획 수립** → 스케줄러 + etcd
3. **실행 지시** → 각 워커 노드
4. **실제 실행** → kubelet + 컨테이너 런타임
5. **상태 관리** → 컨트롤러 매니저 + kubelet

이렇게 마스터 노드가 "두뇌" 역할을 하고, 워커 노드들이 "손발" 역할을 하면서 하나의 통합된 시스템으로 동작합니다! 🚀
