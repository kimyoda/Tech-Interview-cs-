# 🐳 Docker 기본 개념(내용 추가)

## 1. Docker 기본 개념

- Docker는 애플리케이션을 \*\*컨테이너(Container)라는 가벼운 실행 환경으로 패키징하고 배포하는 플랫폼이다. 컨테이너는 동일한 OS 커널을 공유하고 프로세스와 파일 시스템을 격리해 가상머신보다 빠르게 시작되고 자원을 적게 사용한다.
- Docker의 주요 개념, 구성 요소를 정리, 가상 머신과 차이, 네트워킹, 데이터 관리, Docker Compose 등을 소개한다.

### 1-1.Docker란 무엇인가

- Docker는 **컨테이너 기반 가상화 플랫폼**이다. 컨테이너는 애플리케이션과 필요한 의존성을 묶어 하나의 이미지로 패키징 한 뒤, 호스트 OS 커널을 공유하고 격리된 프로세스로 실행된다.
- 애플리케이션과 환경을 동일하게 배포할 수 있어 개발-운영 환경의 불일치를 줄이고, 빠른 배포와 확장성을 제공한다. 컨테이너는 가상머신보다 리소스를 적게 사용하고 DevOps를 촉진한다.

#### 1.1 컨테이너 vs. 가상머신

| 구분        | 가상머신                           | 컨테이너                                |
| ----------- | ---------------------------------- | --------------------------------------- |
| 가상화 방식 | 하이퍼바이저 위에서 전체 OS를 실행 | 호스트 OS 커널을 공유하는 프로세스 격리 |
| 리소스 사용 | GB 단위 메모리 필요                | MB 단위 메모리 필요로 경량화            |
| 시작 속도   | OS 부팅 필요 → 느림                | 프로세스 수준 → 빠름                    |
| 격리 수준   | 하드웨어 레벨 가상화               | OS 레벨 가상화                          |

- 가상머신은 하이퍼바이저 위에 게스트 OS를 포함하여 무겁고 느린 반면, 컨테이너는 **Linux namespace**와 **cgroups**를 통해 격리와 자원 제한을 구현한다.
- 컨테이너는 더 많은 인스턴스를 효율적으로 운영할 수 있고, 이미지 기반 배포로 운영 환경과 개발 환경을 일치시킨다.

---

## 2. Docker 구성 요소

### 2-1. Docker Engine

- Docker의 핵심 실행 엔진이다. dockerd 데몬과 docker CLI로 구성되어 컨테이너 생성, 실행, 관리 작업을 담당한다. 데몬은 백그라운드에서 API 요청을 처리, CLI는 사용자와 데몬 사이의 인터페이스 역할을 한다.

### 2-2. 이미지(Image)

- 컨테이너 실행에 필요한 코드, 라이브러리, 설정 등을 포함한 읽기 전용 템플릿이다.
- 이미지는 여러 개의 **레이어(Layer)**로 구성되고, 각 레이어는 부모 레이어위에 겹치는 방식으로 저장된다.
- 이미지에서 컨테이너를 실행할 때 이미지 레이어 위에 **쓰기 가능한 컨테이너 레이어**가 생성, 이 레이어는 컨테이너가 삭제되면 함께 사라진다.

- 중복제거: 동일한 레이어는 여러 이미지에서 공유돼 저장 공간을 절약한다.
- 빠른 빌드: 변경된 레이어만 다시 빌드하여 이미지 빌드 및 다운로드 속도가 빨라진다.
- 캐싱: 레이어 캐시를 활용해 지속적인 통합/배포/(CI/CD)에서 시간을 줄일 수 있다.

### 2.3 컨테이너(Container)

- 이미지를 실행할 인스턴스다. 컨테이너는 격리된 프로세스와 파일 시스템을 가지고, 생성, 시작, 중지, 삭제가 가능하다.
- 컨테이너의 수명은 이미지와 독립적이고, 컨테이너를 삭제해도 이미지는 그대로 유지된다.

### 2.4 Dockerfile

- 이미지를 빌드하기 위한 명령어 스크립트이다.
- 선언적 방식으로 베이스 이미지, 패키지 설치, 환경 변수 설정 등을 정의
- `docker build` 명령으로 재현 가능한 빌드를 수행한다.
- Git과 같은 버전 관리 시스템에 Dockerfile을 관리하고 환경 변경을 추적할 수 있다.

## 3. Docker 이미지의 레이어 구조

- Docker 이미지는 여러 개의 **읽기 전용 레이어**로 구성되어, 컨테이너를 실행할 때 이미지 레이어 위에 쓰기 가능한 레이어가 추가된다.
- 기본 레이어에는 배포 OS(예: ubuntu:20.04)가 포함, 그 위 애플리케이션 코드와 라이브러리가 추가된다.
- Docker Engine은 Union File System을 사용해 여러 레이어를 하나의 파일 시스템으로 합치고, 컨테이너에서 파일을 수정하면 **Copy-on-Write** 방식으로 새로운 레이어가 생성된다.
- 레이어 캐싱과 중복 제거가 가능해져 저장공간과 빌드 시간이 절약된다.

## 4. 네트워킹: 컨테이너 통신의 기본

- Docker는 기본적으로 여러 종류의 네트워크 드라이버를 제공한다. 컨테이너의 용도와 환경에 맞춰 적절한 네트워크를 선택하면 된다.

### 4.1 Bridge 네트워크

- Bridge 네트워크는 단일 호스트 내에서 가장 흔히 사용되는 기본 드라이버다.
- IPv4(선택적으로 IPv6) 서브넷을 갖고 있고, 같은 네트워크에 연결된 컨테이너 간 통신을 허용하며 다른 네트워크나 외부로부터 격리된다.
- 특징은 다음과 같다.
  - 통신 범위: 같은 Bridge 네트워크에 연결된 컨테이너끼리만 통신 가능하고, 다른 네트워크의 컨테이너와는 포트 포워딩을 통해서 통신한다.
  - 포트 퍼블리싱: `-p` 플래그를 사용해 컨테이너 포트를 호스트 포트와 매핑할 수 있다.
  - 기본 네트워크: Docker를 설치하고 `docker0` 라는 기본 bridge 네트워크가 생성되고, 특별한 지정이 없으면 컨테이너는 기본 네트워크에 연결된다.
  - 사용자 정의 네트워크: `docker network create` 명령으로 사용자 정의 브리지 네트워크를 만들 수 있고, 자동 DNS 해결과 향상된 격리성을 제공한다.

### 4.2 Host 네트워크

- Host 모드에서 컨테이너가 호스트의 네트워크 스택을 그대로 사용한다. NAT나 프록시가 없어 성능 최적화에 유리하고, 많은 포트를 처리해야 하는 컨테이너에 적합하다.
- 컨테이너는 더 이상 독립적인 네임스페이스를 갖지 않아 다음 사항에 유의해야 한다.
  - 포트 중복: 컨테이너가 호스트 포틀를 직접 사용해 동일 포트를 사용하는 여러 컨테이너를 동시에 실행할 수 없다.
  - 지원 플랫폼: 리눅스 호스트에서 사용 가능, Docker Desktop에서 4.34 버전 이후에 설정을 통해 활성화해야 한다.
  - 제한: 보안 강화(ECR / Enhanced Container Isolation)모드와 호환되지 않고 Windows 컨테이너에서 작동하지 않는다.

### 4.3 Overlay 네트워크

- Overlay 네트워크는 여러 Docker 호스트에 걸쳐 있는 컨테이너 간 통신을 가능하게 한다. Swarm 모드로 클러스터를 구성해야 하고, 각 노드 간에 특정 포트를 열어 두어야 한다.
  - 분산 환경: 다른 호스트에 있는 컨테이너 끼리도 하나의 가상 네트워크로 묶어 통신할 수 있다.
  - Swarm 연동: Standalone 컨테이너를 연결할 때도 Swarm 모드를 초기화해야하고 `--attachable` 옵션으로 일반 컨테이너도 overlay 네트워크에 참여할 수 있다.
  - 암호화 지원: `--opt encrypted` 옵션을 사용해 VXLAN 수준에서 IPsec 암호화를 화성해 네트워크를 보호할 수 있다.
  - 제한 사항: 1000개 이상 컨테이너가 한 호스트에 물릴 경우 성능 문제가 발생할 수 있다.

### 4.4 Macvlan 네트워크

- Macvlan 드라이버는 각 컨테이너에 고유한 MAC 주소를 할당해 물리적인 네트워크 장치처럼 보이게 만든다.
- 물리 네트워크와 직접 통신해야 하거나 DHCP 서버에 직접 IP 주소를 할당받는 상황에서 사용된다.
  - 전용 인터페이스 지정: 컨테이너 트래픽이 지나갈 물리 인터페이스(`parent`)를 지정해야 하고, 서브넷과 게이트웨이도 명시한다.
  - 플랫폼 제한: 리눅스에서만 지원 되고, Docker Desktop이나 Windows 엔진에서는 사용할 수 없다.
  - 호스트와 통신 불가: 컨테이너는 호스트와 직접 통신할 수 없고, 필요하면 브리지 네트워크를 추가 연결해야 한다.
  - 네트워크 장비 요구: 여러 MAC 주소를 처리할 수 있는 스위치 등 네트워크 장비가 필요하고, 무분별한 MAC 주소 증가로 네트워크 성능이 저하될 수 있다.

### 4.5 None 네트워크

- `--network none` 옵션을 지정하면 컨테이너는 오직 루프백 인터페이스만 갖게 된다.
- 외부와 완전히 격리된 환경을 구성할 떄 사용되고, IPv6 루프백 주소는 생성되지 않는다.

### 4.6 컨테이너 간 통신 방법

- 동일 네트워크: 같은 브리지나 overlay 네트워크에 연결된 컨테이너는 이름(DNS)으로 서로를 참조할 수 있다.
- 사용자 정의 브리지에서 컨테이너 이름으로 자동 DNS 해결이 가능하나, 기본 `docker0` 브리지에서 IP로 접근해야 한다.
- 포트 매핑: `-P 호스트포트:컨테이너포트` 형태로 호스트 포트를 열어 외부나 다른 네트워크 컨테이너가 접근할 수 있도록 한다.
- 볼륨 공유: 파일 시스템을 공유해 데이터를 주고받거나 설정 파일을 공유할 수 있다.

---

## 5. 데이터 관리: 볼륨과 마운트

- 컨테이너는 이미지의 읽기 전용 레이어 위에 생성된 **쓰기 레이어**에 데이터를 저장한다.
- 쓰기 레이어는 컨테이너가 삭제되면 함께 사라져서, **지속성이 필요한 데이터**는 외부 스토리지에 저장해야 한다.
- Docker는 세가지 주요 마운트 방식을 제공한다.

| 방식                      | 저장 위치                                           | 특징                                                                                                                                                   | 사용 사례                                        |
| ------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------ |
| 볼륨(Volume)              | Docker가 관리하는 경로 (`/var/lib/docker/volumes/`) | Docker가 직접 관리하는 영속 스토리지. 명령어로 생성/백업 가능, 여러 컨테이너가 공유 가능, Windows/리눅스 모두 지원. 컨테이너 삭제 후에도 데이터가 남음 | 데이터베이스 데이터, 로그, 영속성 있는 파일 저장 |
| 바인드 마운트(Bind Mount) | 호스트 파일 시스템의 특정 경로                      | 호스트 디렉터리를 컨테이너에 그대로 마운트. 개발 시 코드 동기화에 유용하지만 호스트 경로 의존성이 있고 보안 리스크가 생길 수 있음                      | 소스 코드 공유, 설정 파일 커스터마이징           |
| tmpfs 마운트              | 호스트 메모리(RAM)                                  | 메모리에만 저장되며 컨테이너 종료 시 데이터가 사라짐. 민감 데이터/임시 파일에 적합                                                                     | 세션 데이터, 캐시                                |

### 5.1 볼륨 관리

- 생성: `docker volume create <name>`
- 조회: `docker volume ls`, `docker volume inspect <name>`
- 컨테이너 연결: `docker run -v  <volume>:/path/pin/continaer ...`
- 백업: 호스트에서 볼륨 데이터 디렉터리를 tar로 백업
- 정리: 사용하지 않는 볼륨을 `docker volume prune`으로 제거
- 라이프사이클: 컨테이너가 삭제되어도 볼륨 데이터는 남아있어 재사용과 백업에 유리하다.
